# LeetCode 数组题刷题

### 941有效山脉数组 Easy
**Key points:**
- 当需要判断是递增顺序时：`arr[i] < arr[i+1] | arr[i] <= arr[i+1]`
- 当需要判断是递减顺序时：`arr[i] > arr[i+1] | arr[i] >= arr[i+1]`
需要注意`i` 为数组index， 并 `i+1 < n`, `n`为数组长度，如果不判断 `i+1 < n`会出现越界行为。

### 189 轮转数组 Medium
**Description**:
给定一个整数数组 nums，将数组中的元素向右轮转 k 个位置，其中 k 是非负数。


**Key points:**
- 当将一个数组下标为`i`旋转`k`个位置后，新的位置为 `(i + k) % n`
- 环状替换法：
  - 每个元素都移动到正确的位置：通过环状替换，每个元素都被放置到旋转 k 个位置后应该在的地方。
  - 不遗漏也不重复：算法确保每个元素只移动一次，并且每个位置都被新的元素占据。
  - 处理循环：当数组长度 n 和步数 k 有共同的因数时，仅仅从第一个元素开始并不足以覆盖数组中的所有元素。这就是为什么要有外层循环，从数组中的不同位置开始，以确保每个元素都被移动。
  - 举例：`nums=[1,2,3,4,5,6,7], k = 3`:
    1. 开始位置：从位置 0 (元素 1) 开始。
    2. 第一轮替换：
         - 将位置 0 的元素（1）移动到 (0 + k) % n = 3 的位置。
         - 位置 3 的原始元素（4）被保留，并移动到下一个目标位置。
         - 数组现在是 [4, 2, 3, 1, 5, 6, 7]。
    3. 继续替换：
         - 接下来，我们将位置 3 的原始元素（4）移动到 (3 + k) % n = 6 的位置。
         - 位置 6 的原始元素（7）被保留，并移动到下一个目标位置。
         - 数组变为 [4, 2, 3, 1, 5, 6, 4]。
    4. 继续替换：
         - 将位置 6 的原始元素（7）移动到 (6 + k) % n = 2 的位置。
         - 位置 2 的原始元素（3）被保留，并移动到下一个目标位置。
         - 数组变为 [4, 2, 7, 1, 5, 6, 4]。
    5. 继续此过程，直到我们回到起始位置。在这个例子中，我们在移动了 7 次（数组长度）后回到起点。
    6. 如果需要，从下一个未处理的元素开始新一轮替换。在这个例子中，每个元素都已经被正确移动到位，所以不需要进行额外的循环。
- 数组翻转法：当我们将数组的元素向右移动 kk 次后，尾部 (k mod n)个元素会移动至数组头部，其余元素向后移动 (k mod n)个位置。

### 665 非递减数列 Medium
**Key points:**
- 当 `i` 为数组 `index`, `n`为数组长度时，判断非递减/递增为 `i+1<n && nums[i] < nums[i+1]`
- 需要注意：本题表示，我们可以修改数组中的一个值，所以当出现 `num[i+1] > nums[i]` 的情况时：
  - 修改 `nums[i+1]`, 当 `nums[i+1] < nums[i-1]`, 注意 `nums[i]`为当前元素，原因在于，`nums[i]` 之前的序列已经为非递减序列。如果修改 `nums[i]` 为`nums[i+1]` 此时队列还存在问题。这个数组仍然会出现非递减的情况。这时的公式为: `nums[i+1] = nums[i]`
  - 修改 `nums[i]`为 `nums[i+1]`, 直接修改`nums[i]`的值，比较直观。

### 228 汇总区间 Easy
**Key points:**
- 从头到尾遍历数组，模拟操作即可


### 163 缺失的区间 Easy
**Key points:**
- 如果当前元素和前一个元素的差小于等于2，则说明没有缺失的区间。

### 31 下一个排列
**Key points:**
首先明确一个数组中的全排列为 `n!`的数量，拿 `arr = [1,2,3]` 举例，按字典序的全排列为： `[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]`。当找寻下一个排列时，通过观察可知：
- 当数组为倒序时，直接返回顺序排列, 在非倒序的情况下，下一个排列的大小总是比当前排列要大，所以我们需要找到一种方法，能够找一个大于当前序列的新序列，且变大幅度为最小： 1。我们需要将左边的【较小数】与一个右边的【较大数】交换，目的是能够让当前排列变大 2. 同时需要让【较小数】尽量靠右，而【较大数】尽可能小。当完成交换后，【较大数】右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。

### 135 分发糖果
**Key Points:**
我们可以将「相邻的孩子中，评分高的孩子必须获得更多的糖果」这句话拆分为两个规则，分别处理:
1. 左规则： 当 `ratings[i-1] < ratings[i]`时 `children[i] = children[i-1] + 1`
2. 右规则： 当 `ratings[i] > ratings[i+1]`时 `children[i] = children[i+1] + 1`
*反思*： 能否两边同时考虑？不太行，因为有些ratings会依赖后面ratings中分配的糖果数，如果一次遍历针对两边取值或两次遍历同一方向会有问题。

